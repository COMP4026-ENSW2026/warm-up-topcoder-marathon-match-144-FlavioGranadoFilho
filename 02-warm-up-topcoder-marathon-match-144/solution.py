# -*- coding: utf-8 -*-
"""solution

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RCFGakhyFMKVSmR9FbHeqHHwTk7McyNF
"""

from collections import deque

def is_valid_cell(row, col, grid):
    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):
        return False
    cell = grid[row][col]
    return cell != '#' and cell != 'W' and cell != 'B'

def bfs(row, col, grid):
    queue = deque([(row, col, 0)])
    visited = set([(row, col)])
    farthest_distance = 0

    while queue:
        curr_row, curr_col, distance = queue.popleft()

        farthest_distance = max(farthest_distance, distance)

        for dr, dc in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
            new_row, new_col = curr_row + dr, curr_col + dc

            if is_valid_cell(new_row, new_col, grid) and (new_row, new_col) not in visited:
                queue.append((new_row, new_col, distance + 1))
                visited.add((new_row, new_col))
                grid[new_row][new_col] = 'W'

    return farthest_distance

def find_optimal_action(row, col, grid, water_distance):
    for dr, dc in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
        new_row, new_col = row + dr, col + dc

        if is_valid_cell(new_row, new_col, grid):
            cell = grid[new_row][new_col]
            if cell == '.' or cell == '*':
                return ('M', dr, dc)

    return ('B', 0, 0)

def solve(grid):
    H, W = len(grid), len(grid[0])
    taps = []
    builders = []

    for row in range(H):
        for col in range(W):
            cell = grid[row][col]
            if cell == 'T':
                taps.append((row, col))
            elif cell == 'B':
                builders.append((row, col))

    farthest_distances = [bfs(row, col, grid) for row, col in taps]

    builders.sort(key=lambda b: min(abs(b[0] - t[0]) + abs(b[1] - t[1]) for t in taps))

    actions = []
    turn = 0

    while any(farthest_distance >= turn for farthest_distance in farthest_distances):
        actions.append(str(len(builders)))

        for builder in builders:
            row, col = builder
            action_type, dr, dc = find_optimal_action(row, col, grid, farthest_distances[0])

            if action_type == 'M':
                new_row, new_col = row + dr, col + dc
                grid[row][col], grid[new_row][new_col] = grid[new_row][new_col], grid[row][col]
                actions.append(f"{row} {col} {action_type} {('L', 'U', 'R', 'D')[dr + 1]}")
                builder = (new_row, new_col)
            elif action_type == 'B':
                actions.append(f"{row} {col} {action_type} {'LRUD'[dc + 1]}")

        turn += 1

    return actions

H = int(input())
W = int(input())
T = int(input())
B = int(input())
S = int(input())

grid = []
for _ in range(H):
    row = input().strip()
    grid.append(list(row))

actions = solve(grid)

print(len(actions))
for action in actions:
    print(action)